#!/usr/bin/env python3
#	macOS:
#		brew install gmp
#		sudo env "CFLAGS=-I/usr/local/include -L/usr/local/lib" pip3 install pycrypto
#	Linux:
#		sudo PACKAGE_MANAGER install python3-dev
#		sudo pip3 install pycrypto
#	Testing:
#		./egit encrypt
#		./egit decrypt
#		./egit status
import csv
import errno
import getpass
import glob
import hashlib
import os
import sys
from Crypto.Cipher import AES
from Crypto import Random

#Create random encrypt file
def encrypt_randfile(key,filename):
	try:
		write_file(filename,encrypt_bytes(key,Random.get_random_bytes(32)))
	except Exception:
		raise Exception('Error encrypting "'+os.path.relpath(filename)+'".')

#Create random decrypt file
def decrypt_randfile(key,filename):
	try:
		decrypt_bytes(key,read_file(filename))
	except Exception:
		raise Exception('Invalid password.')

#Only .gitignore
def is_gitignore(path):
	return os.path.basename(path)=='.gitignore'

#Checks if path is in ignores (or is a child of one of them)
def is_ignored(ignores,path):
	if path in ignores:
		return True
	for ignore in ignores:
		if path.find(ignore+os.sep)==0:
			return True
	return False

#Read a .gitignore file
def read_gitignore(path):
	try:
		lines=open(path,'r').read().split('\n')
		ignores=[]
		for line in lines:
			line=line.strip()
			if len(line)==0 or line[0]=='#':
				continue
			ignores.append(line)
		return ignores
	except Exception:
		raise Exception('Couldn\'t read .gitignore "'+path+'".')

#Returns all files affected by a .gitignore file
def glob_gitignore(ignore_parent_lines,global_root,path):
	local_root=os.path.dirname(path)
	files=[]
	lines=read_gitignore(path)
	ignore_parent_lines[local_root]=lines

	for key in ignore_parent_lines:
		if key!=local_root and local_root.find(key)==0:
			lines+=ignore_parent_lines[key]

	for root,subdirs,ignore_this in os.walk(local_root):
		for line in lines:
			test=os.path.join(root,line)
			for file in glob.glob(test):
				file=os.path.normpath(file)
				if file!=global_root and file not in files:
					files.append(file)

	return ignore_parent_lines,files

#Finds the closest child .git folder and returns its parent
def find_git_root():
	try:
		git_root=os.path.realpath(os.getcwd())
		while True:
			if os.path.isdir(os.path.join(git_root,'.git')):
				return git_root
			if git_root=='/':
				raise Exception('')
			git_root=os.path.dirname(git_root)
	except Exception:
		raise Exception('Couldn\'t find git root - is this in a git repo?')

#Print fancy colors on ANSI terminals (default on pretty much everything except Windows...)
def print_red(data):
	print('\033[91m'+str(data)+'\033[0m')
def print_green(data):
	print('\033[92m'+str(data)+'\033[0m')
def print_orange(data):
	print('\033[93m'+str(data)+'\033[0m')

#Makes an egit list entry from an fpath (looks up status and returns tuple)
def make_egit_lists_entry(fpath):
	stats=os.stat(fpath)
	return [stats.st_mtime,stats.st_mode]

#Check if the modes of the given paths are the same
def compare_modes(fpath1,fpath2):
	return os.stat(fpath1).st_mode==os.stat(fpath2).st_mode

#Checks if the mtime of the given file matches the entry in the given egit list
#  Returns None when the path is not in the list or True/False otherwise
def check_egit_list_mtime(lists,path):
	if path not in lists:
		return None
	return lists[path][0]==os.stat(path).st_mtime

#Checks if the mode of the given file matches the entry in the given egit list
#  Returns None when the path is not in the list or True/False otherwise
def check_egit_list_mode(lists,path):
	if path not in lists:
		return None
	return lists[path][1]==os.stat(path).st_mode

#Read egit lists file
def read_egit_lists(git_root,fname):
	lists={}

	#Doesn't exist, return
	try:
		if not os.path.exists(fname):
			return lists
	except Exception:
		raise Exception('Error reading stats "'+fname+'".')

	#Not a file, raise Exception
	if not isfile(fname):
		raise Exception('"'+fname+'" is not a regular file.')

	#Open file
	csvfile=None
	try:
		csvfile=open(fname,'r')
	except Exception:
		raise Exception('Could not open "'+fname+'" for reading.')

	#Parse csv
	csvreader=None
	try:
		csvreader=csv.reader(csvfile)
	except Exception:
		raise Exception('"'+fname+'" is not a csv file.')

	#Get entries
	lineno=0
	for row in csvreader:
		lineno+=1

		#Rows are: modify_time,file_path
		if len(row)!=0 and len(row)!=3:
			raise Exception('Invalid number of elements on line '+str(lineno)+' of "'+fname+'".')

		#Empty line...skip...
		if len(row)==0:
			continue

		#Get absolute path
		abs_path=os.path.join(git_root,row[2])

		#Check if path exists (if it doesn't, we don't want to keep it in db)
		if not isfile(abs_path):
			continue

		#Parse modify time entry
		mtime=0.0
		try:
			mtime=float(row[0])
		except Exception:
			raise Exception('Invalid time entry on line '+str(lineno)+' of "'+fname+'".')

		#Parse mode entry
		mode=0
		try:
			mode=int(row[1])
		except Exception:
			raise Exception('Invalid mode entry on line '+str(lineno)+' of "'+fname+'".')

		#Add entry
		lists[abs_path]=[mtime,mode]

	#Return a map of fpaths to times
	return lists

#Read egit lists file
def write_egit_lists(git_root,fname,lists):

	#Not a file, raise Exception
	if os.path.exists(fname) and not isfile(fname):
		raise Exception('"'+fname+'" is not a regular file.')

	#Open file
	csvfile=None
	try:
		csvfile=open(fname,'w')
	except Exception:
		raise Exception('Could not open "'+fname+'" for writing.')

	#Write csv
	try:
		csvwriter=csv.writer(csvfile)
		for key in lists:
			rel_path=key.replace(os.path.normpath(git_root)+os.sep,'',1)
			csvwriter.writerow([lists[key][0],lists[key][1],rel_path])
	except Exception as error:
		raise Exception('Error writing to "'+fname+'":\n\t'+str(error))

#Check egit lists for stat changes
def check_egit_lists(lists,path,stats):
	return path in lists and lists[path][0]==stats.st_mtime and lists[path][1]==stats.st_mode

#Sha256 wrapper...
def sha256(data):
	return hashlib.sha256(data).digest()

#https://stackoverflow.com/questions/12524994/encrypt-decrypt-using-pycrypto-aes-256
class AES256Cipher(object):
	def __init__(self,key):
		self.bs=32
		self.key=hashlib.sha256(key.encode()).digest()

	#Encrypt bytes into bytes that look like:
	#	iv_16b | sha256(key)_32b | data
	#	iv is the first 16 bytes of the sha256(data)
	#		Note: This might seem insecure...
	#			  But it with git checking in mind, this means that data that's encrypted will have the same hash....
	def encrypt(self,data):
		iv=sha256(data)[:AES.block_size]
		data=self.pad_m(self.key+data)
		cipher=AES.new(self.key,AES.MODE_CBC,iv)
		return iv+cipher.encrypt(data)

	#Decrypt bytes (see desc of encrypt) into bytes (just data)
	#	Will through if keys don't match
	def decrypt(self,data):
		iv=data[:AES.block_size]
		cipher=AES.new(self.key,AES.MODE_CBC,iv)
		data=cipher.decrypt(data[AES.block_size:])
		data=self.unpad_m(data)
		if data[:len(self.key)]!=self.key:
			raise Exception('Bad Decrypt')
		return data[len(self.key):]

	def pad_m(self,data):
		pad_len=AES.block_size-(len(data)%AES.block_size)
		return data+bytes([pad_len])*pad_len

	def unpad_m(self,data):
		pad_len=int(data[-1])
		return data[:len(data)-pad_len]

#Encrypts bytes with key
def encrypt_bytes(key,data):
	return AES256Cipher(key=key).encrypt(data)

#Decrypts bytes with key
def decrypt_bytes(key,data):
	return AES256Cipher(key=key).decrypt(data)

#Checks if path is a file (an actual regular file, not a pipe...come on python...)
def isfile(path):
	return os.path.isfile(path) and not os.path.islink(path)

#Read a binary file (why isn't this the default python?!)
def read_file(path):
	return open(path,'rb').read()

#Write a binary file (why isn't this the default python?!)
def write_file(path,data):
	open(path,'wb').write(data)

#Remove a file (ignores does not exist error)
def remove_file(path):
	try:
		os.remove(path)
	except OSError as error:
		if error.errno!=errno.ENOENT:
			raise

#Prompt user for yes/no (prefix is added to prompts...)
def confirm(prompt,prefix=''):
	while True:
		ans=input('\033[93m'+prefix+prompt+'\033[0m').strip()
		if ans=='yes':
			return True
		if ans=='no':
			return False
		prompt='Type "yes" or "no": '

#Splits a path into tokens (so 'a/b/c' turns into ['a','b','c'])
def split_path(path):
	tokens=[path]
	while True:
		parent,child=os.path.split(tokens[0])
		if len(parent)==0 or len(child)==0:
			break
		tokens=[parent,child]+tokens[1:]
	return tokens

#Takes a string file path and returns the encrypted hex string
def encrypt_fpath(encrypt_dir,key,dec_path):
	try:
		enc_path=''
		for path in split_path(dec_path):
			hexname=AES256Cipher(key=key).encrypt(path.encode('utf-8')).hex()
			if len(hexname)%2!=0:
				hexname='0'+hexname
			enc_path=os.path.join(enc_path,hexname)
		return enc_path
	except Exception:
		raise Exception('Error encrypting the following file path:\n"%s"'%os.path.join(encrypt_dir,enc_path))

#Takes a hex string and returns the decrypted file path
def decrypt_fpath(encrypt_dir,key,enc_path):
	try:
		dec_path=''
		for path in split_path(enc_path):
			dec_path=os.path.join(dec_path,AES256Cipher(key=key).decrypt(bytes.fromhex(path)).decode('utf-8'))
		return dec_path
	except Exception:
		raise Exception('Error decrypting the following file path:\n"%s"'%os.path.join(encrypt_dir,enc_path))

#Recursively find differences in decrypt_dir and encrypt_dir
def status_files(git_root,lists_path,lists,key,decrypt_dir,encrypt_dir):
	ignore_parent_lines={}
	ignores=[]
	fails=[]
	new_files=[]
	del_files=[]
	diff_files=[]

	#Get files to ignore via .gitignore files
	for root,subdirs,files in os.walk(decrypt_dir):
		for file in files:
			try:
				path=os.path.join(os.path.join(root,file))
				if isfile(path) and is_gitignore(path):
					ignore_parent_lines,new_ignores=glob_gitignore(ignore_parent_lines,decrypt_dir,path)
					ignores+=new_ignores

			except Exception as error:
				error='Error handling "'+path+'")'+':\n\t'+str(error)
				fails.append((path,error))
				print_red(error)
				return

	#Handle decrypted files
	for root,subdirs,files in os.walk(decrypt_dir):
		for file in files:
			decrypt_path=os.path.join(root,file)
			encrypt_path=os.path.join(encrypt_dir,encrypt_fpath(encrypt_dir,key,os.path.relpath(decrypt_path,decrypt_dir)))

			#Source isn't a regular file, skip it
			if not isfile(decrypt_path):
				continue

			#File matches a .gitignore file - skip
			if is_ignored(ignores,decrypt_path):
				continue

			#Check file stats (faster)
			try:
				stats=os.stat(decrypt_path)
				if not isfile(encrypt_path):
					new_files.append(decrypt_path)
					continue
				if check_egit_lists(lists,decrypt_path,stats):
					continue
			except Exception as error:
				error='FAILED (error checking stats)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Check mode
			if check_egit_list_mode(lists,decrypt_path)==False:
				if decrypt_path not in diff_files:
					diff_files.append(decrypt_path)
				continue

			#Read source file
			try:
				data=read_file(decrypt_path)
			except Exception as error:
				error='FAILED (error reading)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Encrypt source
			try:
				data=encrypt_bytes(key,data)
			except Exception as error:
				error='FAILED (error encrypting)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Check for differences
			try:
				if isfile(encrypt_path):
					if sha256(data)==sha256(read_file(encrypt_path)) and compare_modes(decrypt_path,encrypt_path):
						lists[decrypt_path]=make_egit_lists_entry(decrypt_path)
						lists[encrypt_path]=make_egit_lists_entry(encrypt_path)
						continue
					if decrypt_path not in diff_files:
						diff_files.append(decrypt_path)
					continue
			except Exception as error:
				error='FAILED (error checking for changes)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

	#Handle encrypted files
	for root,subdirs,files in os.walk(encrypt_dir):
		for file in files:
			encrypt_path=os.path.join(root,file)
			decrypt_path=os.path.join(decrypt_dir,decrypt_fpath(encrypt_dir,key,os.path.relpath(encrypt_path,encrypt_dir)))

			#Source isn't a regular file, skip it
			if not isfile(encrypt_path):
				continue

			#File matches a .gitignore file - skip
			if is_ignored(ignores,encrypt_path):
				continue

			#Check file stats (faster)
			try:
				stats=os.stat(encrypt_path)
				if not isfile(decrypt_path):
					del_files.append((decrypt_path,encrypt_path))
					continue
				if check_egit_lists(lists,encrypt_path,stats):
					continue
			except Exception as error:
				error='FAILED (error checking stats)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Check mode
			if check_egit_list_mode(lists,encrypt_path)==False:
				if decrypt_path not in diff_files:
					diff_files.append(decrypt_path)
				continue

			#Read source file
			try:
				data=read_file(encrypt_path)
			except Exception as error:
				error='FAILED (error reading)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Decrypt source
			try:
				data=decrypt_bytes(key,data)
			except Exception as error:
				error='FAILED (error decrypting)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Check for differences
			try:
				if isfile(decrypt_path):
					if sha256(data)==sha256(read_file(decrypt_path)) and compare_modes(encrypt_path,decrypt_path):
						lists[decrypt_path]=make_egit_lists_entry(decrypt_path)
						lists[encrypt_path]=make_egit_lists_entry(encrypt_path)
						continue
					if decrypt_path not in diff_files:
						diff_files.append(decrypt_path)
					continue
			except Exception as error:
				error='FAILED (error checking for changes)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

	#Update egit lists
	write_egit_lists(git_root,lists_path,lists)

	#Print Stats
	print('')
	print(str(len(new_files))+' New Files')
	for file in new_files:
		print_green('\t'+os.path.relpath(file))
	print(str(len(del_files))+' Deleted Files')
	for f1,f2 in del_files:
		print_red('\t%s (%s)'%(os.path.relpath(f1),os.path.relpath(f2)))
	print(str(len(diff_files))+' Different Files')
	for file in diff_files:
		print_orange('\t'+os.path.relpath(file))
	print(str(len(fails))+' Fails')
	for fail in fails:
		for line in ('"'+os.path.relpath(fail[0])+'" - '+fail[1]).split('\n'):
			print_red('\t'+line)

#Recursively encrypt files in decrypt_dir into encrypt_dir (won't overwrite with confirmation)
def encrypt_files(git_root,lists_path,lists,key,decrypt_dir,encrypt_dir):
	ignore_parent_lines={}
	num_encrypted=0
	num_skipped=0
	ignores=[]
	fails=[]

	#Get files to ignore via .gitignore files
	for root,subdirs,files in os.walk(decrypt_dir):
		for file in files:
			try:
				path=os.path.join(os.path.join(root,file))
				if isfile(path) and is_gitignore(path):
					ignore_parent_lines,new_ignores=glob_gitignore(ignore_parent_lines,decrypt_dir,path)
					ignores+=new_ignores

			except Exception as error:
				error='Error handling "'+path+'")'+':\n\t'+str(error)
				fails.append((path,error))
				print_red(error)
				return

	#Handle files
	for root,subdirs,files in os.walk(decrypt_dir):
		for file in files:
			decrypt_path=os.path.join(os.path.join(root,file))
			encrypt_path=os.path.join(encrypt_dir,encrypt_fpath(encrypt_dir,key,os.path.relpath(decrypt_path,decrypt_dir)))
			data=None
			ignore_success=False

			#Source isn't a regular file, skip it
			if not isfile(decrypt_path):
				continue

			#File matches a .gitignore file - skip
			if is_ignored(ignores,decrypt_path):
				continue

			#Print filename
			sys.stdout.write('"'+os.path.relpath(decrypt_path)+'"...')
			sys.stdout.flush()

			#Check file stats (faster)
			try:
				stats=os.stat(decrypt_path)
				if isfile(encrypt_path) and check_egit_lists(lists,decrypt_path,stats) and compare_modes(encrypt_path,decrypt_path):
					print_orange('Skipping (no stat changes)')
					num_skipped+=1
					continue
			except Exception as error:
				error='FAILED (error checking stats)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Read source file
			try:
				data=read_file(decrypt_path)
			except Exception as error:
				error='FAILED (error reading)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Check for differences
			different=False
			try:
				if isfile(encrypt_path):
					wdata=read_file(encrypt_path)
					wdata=decrypt_bytes(key,wdata)
					different=sha256(data)!=sha256(wdata) or not compare_modes(encrypt_path,decrypt_path)
					if not different:
						lists[decrypt_path]=make_egit_lists_entry(decrypt_path)
						lists[encrypt_path]=make_egit_lists_entry(encrypt_path)
						print_orange('Skipping (no changes)')
						num_skipped+=1
						continue
			except Exception as error:
				error='FAILED (error checking for changes)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Check if destination exists and that it isn't different than source
			try:
				if isfile(encrypt_path) and different:
					print_red('exists')
					if not confirm('Destination file exists and is different, overwrite? (yes/no): ','\t'):
						print_orange('\tSkipped "'+encrypt_path+'"')
						num_skipped+=1
						continue
					print_orange('\tOverwrote "'+encrypt_path+'"')
					ignore_success=True
			except Exception as error:
				error='FAILED (error reading encrypted copy)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Encrypt source
			try:
				data=encrypt_bytes(key,data)
			except Exception as error:
				error='FAILED (error encrypting)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Remove destination file if exists
			try:
				remove_file(encrypt_path)
			except Exception as error:
				error='FAILED (error deleting encrypted copy)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Make destination's parent
			try:
				os.makedirs(os.path.dirname(encrypt_path),exist_ok=True)
			except Exception as error:
				error='FAILED (error making parents)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#Write destination file
			try:
				write_file(encrypt_path,data)
				os.chmod(encrypt_path,os.stat(decrypt_path).st_mode)
				lists[decrypt_path]=make_egit_lists_entry(decrypt_path)
				lists[encrypt_path]=make_egit_lists_entry(encrypt_path)
			except Exception as error:
				error='FAILED (error writing)'+':\n\t'+str(error)
				fails.append((decrypt_path,error))
				print_red(error)
				continue

			#All done
			num_encrypted+=1
			if not ignore_success:
				print_green('success')

	#Update egit lists
	write_egit_lists(git_root,lists_path,lists)

	#Print Stats
	print('')
	print_green(str(num_encrypted)+' Encrypted')
	print_orange(str(num_skipped)+' Skipped')

	#Print Fails
	print_red(str(len(fails))+' Fails')
	for fail in fails:
		for line in ('"'+os.path.relpath(fail[0])+'" - '+fail[1]).split('\n'):
			print_red('\t'+line)

#Recursively decrypt files in encrypt_dir into decrypt_dir (won't overwrite with confirmation)
def decrypt_files(git_root,lists_path,lists,key,decrypt_dir,encrypt_dir):
	num_decrypted=0
	num_skipped=0
	fails=[]
	for root,subdirs,files in os.walk(encrypt_dir):
		for file in files:
			encrypt_path=os.path.join(root,file)
			decrypt_path=os.path.join(decrypt_dir,decrypt_fpath(encrypt_dir,key,os.path.relpath(encrypt_path,encrypt_dir)))
			data=None
			ignore_success=False

			#Print filename
			sys.stdout.write('"'+os.path.relpath(decrypt_path)+'"...')
			sys.stdout.flush()

			#Source isn't a regular file, skip it
			if not isfile(encrypt_path):
				print_orange('Skipping (not a regular file)')
				continue

			#Check creation and modification times (faster)
			try:
				stats=os.stat(encrypt_path)
				if isfile(decrypt_path) and check_egit_lists(lists,encrypt_path,stats) and compare_modes(decrypt_path,encrypt_path):
					print_orange('Skipping (no stat changes)')
					num_skipped+=1
					continue
			except Exception as error:
				error='FAILED (error checking stats)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Read source file
			try:
				data=read_file(encrypt_path)
			except Exception as error:
				error='FAILED (error reading)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Decrypt source
			try:
				data=decrypt_bytes(key,data)
			except Exception as error:
				error='FAILED (error decrypting)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Check for differences
			different=False
			try:
				if isfile(decrypt_path):
					different=sha256(data)!=sha256(read_file(decrypt_path)) or not compare_modes(decrypt_path,encrypt_path)
					if not different:
						lists[decrypt_path]=make_egit_lists_entry(decrypt_path)
						lists[encrypt_path]=make_egit_lists_entry(encrypt_path)
						print_orange('Skipping (no changes)')
						num_skipped+=1
						continue
			except Exception as error:
				error='FAILED (error checking for changes)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Check if destination exists and that it isn't different than source
			try:
				if isfile(decrypt_path) and different:
					print_red('exists')
					if not confirm('Destination file exists and is different, overwrite? (yes/no): ','\t'):
						print_orange('\tSkipped "'+decrypt_path+'"')
						num_skipped+=1
						continue
					print_orange('\tOverwrote "'+decrypt_path+'"')
					ignore_success=True
			except Exception as error:
				error='FAILED (error reading decrypted copy)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Remove destination file if exists
			try:
				remove_file(decrypt_path)
			except Exception as error:
				error='FAILED (error deleting decrypted copy)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Make destination's parent
			try:
				os.makedirs(os.path.dirname(decrypt_path),exist_ok=True)
			except Exception as error:
				error='FAILED (error making parents)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#Write destination file
			try:
				write_file(decrypt_path,data)
				os.chmod(decrypt_path,os.stat(encrypt_path).st_mode)
				lists[decrypt_path]=make_egit_lists_entry(decrypt_path)
				lists[encrypt_path]=make_egit_lists_entry(encrypt_path)
			except Exception as error:
				error='FAILED (error writing)'+':\n\t'+str(error)
				fails.append((encrypt_path,error))
				print_red(error)
				continue

			#All done
			num_decrypted+=1
			if not ignore_success:
				print_green('success')

	#Update egit lists
	write_egit_lists(git_root,lists_path,lists)

	#Print Stats
	print('')
	print_green(str(num_decrypted)+' Decrypted')
	print_orange(str(num_skipped)+' Skipped')

	#Print Fails
	print_red(str(len(fails))+' Fails')
	for fail in fails:
		for line in ('"'+os.path.relpath(fail[0])+'" - '+fail[1]).split('\n'):
			print_red('\t'+line)

#Takes arguments for a git command and runs them.
#  Note 0: Takes all args not starting with a dash and assumes they are files.
#        This then turns them into encrypted names of the files.
#  Note 1: This handles '--' by the standard ignore-after convention.
def handle_git_cmd(git_root,lists_path,lists,key,decrypt_dir,encrypt_dir,mode,args):
	skip_dashes=True
	new_args=[]
	for arg in args:

		#Handle args starting with dashes (if dashes are on)
		if skip_dashes:
			if arg=='--':
				skip_dashes=False
			if arg.startswith('-'):
				new_args.append(arg)
				continue

		#Get absolute decrypt path
		decrypt_path=os.path.abspath(arg)

		#Get encrypted path
		#  If it's the decrypt directory, just use the encrypted directory
		encrypt_path=encrypt_dir
		if decrypt_path!=decrypt_dir:
			encrypt_path=os.path.join(encrypt_dir,encrypt_fpath(encrypt_dir,key,os.path.relpath(decrypt_path,decrypt_dir)))

		#Check path exists, if not, error
		if not os.path.exists(encrypt_path):
			raise Exception('File "%s" not found.'%arg)

		#Add encrypted path to new arg list
		new_args.append(encrypt_path)

	#Execute git command
	os.execvp('git',['git',mode]+new_args)

if __name__=='__main__':
	try:

		#Validate cli args
		modes=['encrypt','decrypt','status','add','rm']
		if len(sys.argv)<2:
			print('Usage: %s %s'%(sys.argv[0],' | '.join(modes)))
			exit(1)

		#Validate mode
		mode=sys.argv[1]
		if mode not in modes:
			raise Exception('Unknown mode.')

		#Validate mode arguments
		modes_with_args=['add','rm']
		if mode not in modes_with_args and len(sys.argv)>2:
			print('Unexpected args.')
			exit(1)
		if mode in modes_with_args and len(sys.argv)<3:
			print('Expected args.')
			exit(1)

		#Validate egit lists file
		git_root=find_git_root()
		lists_path=os.path.join(git_root,'.egit')
		lists=read_egit_lists(git_root,lists_path)

		#Check directories
		decrypt_dir=os.path.join(git_root,'decrypted')
		encrypt_dir=os.path.join(git_root,'encrypted')
		if not os.path.isdir(decrypt_dir):
			raise Exception('"'+decrypt_dir+'" is not a directory.')
		if not os.path.isdir(encrypt_dir) and os.path.exists(encrypt_dir):
			raise Exception('"'+encrypt_dir+'" is not a directory.')

		#Get password
		key=getpass.getpass('Password: ')

		#Randfile doesn't exist, confirm password
		randfilename=os.path.join(git_root,'.egitinit')
		if not isfile(randfilename):
			confirm_key=getpass.getpass('Confirm Password: ')
			if key!=confirm_key:
				raise Exception('Passwords do not match.')
			encrypt_randfile(key,randfilename)

		#Check decryption key
		decrypt_randfile(key,randfilename)

		#Do encrypt/decrypt
		if mode=='encrypt':
			encrypt_files(git_root,lists_path,lists,key,decrypt_dir,encrypt_dir)
		elif mode=='decrypt':
			decrypt_files(git_root,lists_path,lists,key,decrypt_dir,encrypt_dir)
		elif mode=='status':
			status_files(git_root,lists_path,lists,key,decrypt_dir,encrypt_dir)
		elif mode=='add' or mode=='rm':
			handle_git_cmd(git_root,lists_path,lists,key,decrypt_dir,encrypt_dir,mode,sys.argv[2:])
		exit(0)

	#Print errors
	except Exception as error:
		print_red(error)
		exit(1)

	#Kill
	except KeyboardInterrupt:
		exit(1)
